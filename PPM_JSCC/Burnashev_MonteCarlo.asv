% Digital PPM: Simulation of Burnashev scheme
% The simulation is for uniform source
clear all; close all; clc;

ENR = (4:1:15);
ENRlin = 10.^(ENR/10);

Nrun = 7e5;
final_MSE = zeros(1,length(ENR));
final_Beta = zeros(1,length(ENR));

delta = 1/2 + 1/(2*sqrt(2));
dist = {'Gaussian','Uniform'};

for distIdx = 1:length(dist)
    for i=1:length(ENR)
        % pick beta to find the optimal point of the curve
        beta_opt = 3 * exp(ENRlin(i)/6);
        beta = max(1,beta_opt*(0.45:(1/32):3));
        MSE = zeros(size(beta));
        currENRlin = ENRlin(i);
        for beta_idx = 1:length(beta)
            curr_beta = beta(beta_idx);
            currMSE = calc_perf_Burnashev(curr_beta,Nrun,currENRlin,dist{distIdx});
            MSE(beta_idx) = currMSE;
        end
        %     [optVal,optIdx] = min(abs(MSE - 13/8 ./ (beta.*currENRlin).^2));
        [optVal,optIdx] = min(MSE(1:beta_idx));
        final_MSE(i) = MSE(optIdx);
        final_Beta(i) = beta(optIdx);
        disp(strcat('Finished ENR = ',num2str(ENR(i))));
    end
    
    switch dist{distIdx}
        case 'Uniform'
            optSDR_Analytic_Exact = ((delta^(2/3))/4) .* exp(-ENRlin/3);
            opt_beta = 2 * exp(ENRlin/6);
            save('UniformBurnashevOptSDR.mat','ENR','final_MSE','optSDR_Analytic_Exact','final_Beta','opt_beta');
            
            figure;subplot(211);
            hold all;
            plot(ENR,10*log10(1/12./final_MSE),'-.ko','LineWidth',1.5);
            plot(ENR,10*log10(4/12./optSDR_Analytic_Exact),'--ms','LineWidth',1.5);
            xlabel('ENR [dB]'); ylabel('SDR [dB]'); legend({'Empirical','Approximation'},'Location','northwest','FontSize',12);
            grid on; grid minor;
            subplot(212);
            semilogy(ENR,final_Beta,'-.ko','LineWidth',1.5);hold on;
            semilogy(ENR,opt_beta,'--ms','LineWidth',1.5);
            xlabel('ENR [dB]'); ylabel('Optimal Beta');
            grid on; grid minor;
            
        case 'Gaussian'
            optSDR_Analytic_Exact = 0.072 .* exp(-ENRlin/3);
            opt_beta = 2 * exp(ENRlin(i)/6);
            
            save('GaussianBurnashevOptSDR.mat','ENR','final_MSE','optSDR_Analytic_Exact','final_Beta','opt_beta');
            
    end
end


function MSE = calc_perf_Burnashev(beta,Nrun,ENRlin,distType)

beta_round = round(beta);
orthMat = sparse(eye(beta_round));

currMSE = zeros(1,Nrun);
currENR = ENRlin;

%calculate optimal Quantization for the Gaussian case
if strcmp(distType,'Gaussian')
    dx = 1e-4; x = 0:dx:8;
    pdf = (1/sqrt(2*pi))*exp(-x.^2 / 2) * dx;
    
    if mod(beta_round,2) == 0
        indices = (1:beta_round/2).';
        Delta = (1/beta_round):1e-1/beta_round:16/beta_round;
        quant_vals = Delta * indices;
        
    else
        indices = (0:(beta_round - 1)/2).';
        Delta = (1/beta_round):(0.5e-1)/beta_round:16/beta_round;
        quant_vals = indices * Delta;
    end
    
    % calculate the quantization error, to find the optimal delta
    quant_MSE = zeros(1,size(Delta,2));
    for i=1:size(Delta,2)
        if size(quant_vals,1) == 1
            quant_MSE = sum((quants(:) - x.').^2 .* repmat(pdf(:));
        else
            curr_vals =  quant_vals(:,i);
            [~,quants] = quantiz(x,curr_vals(1:end-1) + Delta(i)/2,curr_vals);
            quant_MSE(i) = sum((quants(:) - x(:)).^2 .* pdf(:));
        end
    end
    [~,optDelta_Idx] = min(quant_MSE);
    optDelta = Delta(optDelta_Idx);
    
    if(indices(1) == 0)
        opt_codebook = [-flipud(indices(2:end)) * optDelta;indices * optDelta];
        opt_partition = [flipud(-1*(indices(1:end-1) * optDelta + optDelta/2)); (indices(1:end-1) * optDelta + optDelta/2)];
    else
        opt_codebook =  [-flipud(indices) * optDelta;indices * optDelta];
        opt_partition = [flipud(-1*(indices(1:end-1) * optDelta + optDelta/2)); (indices(1:end-1) * optDelta + optDelta/2)];
    end
    
end

if (beta_round == 1)
    switch distType
        case 'Uniform'
            MSE = 1/12;
        case 'Gaussian'
            MSE = 1;
    end
    return
end
% Generate Quantization Table

parfor n=1:Nrun
    
    % generate source and quantize
    switch distType
        case 'Uniform'
            S = rand - 0.5;  % [-0.5,0.5]
            S_pos = S + 0.5; % [0,1]
            S_q = round((beta_round - 1)* S_pos);
        case 'Gaussian'
            S = randn;
            S_q = quantiz(S,opt_partition,opt_codebook);
    end
    
    % Modulation
    TxPulse = sparse(orthMat(S_q + 1,:));
    TxPulse = sqrt(currENR)*TxPulse;
    
    % AWGN
    noise = randn(size(TxPulse));
    noise = sqrt(1/(2))*noise;% sqrt(2*Fs/W)*noise;
    r = TxPulse + noise;
    
    % Correlator receiver
    corr = orthMat*r(:);
    
    [~,maxIdx] = max(corr);
    
    % De-quantization
    switch distType
        case 'Uniform'
            sHat = (maxIdx - 1 + 0.5)/beta_round - 0.5;
        case 'Gaussian'
            sHat = opt_codebook(maxIdx);
    end
    
    currMSE(n) = (S - sHat)^2;
end

MSE = sum(currMSE)/Nrun;
end